<!doctype html>
<html lang=pl>
<head>
  <meta charset=utf-8>
  <title>Whale Trade Bot</title>

  <script
        src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
        crossorigin="anonymous"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
  <script src="https://canvasjs.com/assets/script/canvasjs.stock.min.js"></script>

<!--   <script>
    var context = {title: "My New Post", body: "This is my first post!"}
    var result = Handlebars.templates.person(context);

    $(function() {
      $("#entry-template").html(result);
    });
  </script> -->

  <script type="text/javascript">
    dashboard_data = { sum:null, ticks:[] };

    // our entry point
    $( document ).ready( () => {
        console.log( "document loaded" );


        let chart = initialize_chart();
        populate_binance_data(chart)
        .then( () => {
          fetch_bucket_data(chart)
          .then( () => {
            chart.chart.render();

              var ema = calculateEMA(chart.data[3] , 7);
              chart.chart.charts[2].addTo("data", {type: "line", name: "Inflows EMA", showInLegend: true,
                                                    yValueFormatString: "#,###", dataPoints: ema, color:"green"});
              var ema = calculateEMA(chart.data[4] , 7);
              chart.chart.charts[2].addTo("data", {type: "line", name: "Outflows EMA", showInLegend: true,
                                                    yValueFormatString: "#,###", dataPoints: ema, color:"red"});

              var ema = calculateEMA(chart.data[6] , 7);
              chart.chart.charts[3].addTo("data", {type: "line", name: "SMA", showInLegend: true,
                                                    yValueFormatString: "#,###", dataPoints: ema, color:"blue"});


          });
        });

        // let limit = 3;
        // let count = 0;
        // while( count < limit && ( !dashboard_data.sum || dashboard_data.sum.api_count == 100)  )
        // {
        //   count++;
        // }




    });

    // SMa doesn't seem to be working (at least not out ofthe box) because of too many 0s
    function calculateEMA(dps,count) {
      var k = 2/(count + 1);
      var emaDps = [{x: dps[0].x, y: dps[0].y.length ? dps[0].y[3] : dps[0].y}];
      for (var i = 1; i < dps.length; i++) {
        emaDps.push({x: dps[i].x, y: (dps[i].y.length ? dps[i].y[3] : dps[i].y) * k + emaDps[i - 1].y * (1 - k)});
      }
      return emaDps;
    }



    function initialize_chart()
    {
      // https://canvasjs.com/javascript-stockcharts/
      var dataPoints1 = [], dataPoints2 = [], dataPoints3 = [], dataPoints4 = [],
            dataPoints5 = [], dataPoints6 = [], dataPoints7 = [];
      var stockChart = new CanvasJS.StockChart("chartContainer",{
        exportEnabled: true,
        theme: "light2",
        title:{ text:"" },
        charts: [

        { 
          toolTip: { shared: true },
          axisX: {
            lineThickness: 5,
            tickLength: 0,
            labelFormatter: function(e) { return ""; },
            crosshair: {
              enabled: true,
              snapToDataPoint: true,
              labelFormatter: function(e) { return "" }
            }
          },
          axisY: {
            title: "BTC Price",
            prefix: "BTC"
         },
          legend: {
            verticalAlign: "top",
            horizontalAlign: "right"
          },
          data: [{
            name: "Price (in USDT)",
            yValueFormatString: "##,###.##",
            xValueFormatString: "MMM DD, YYYY HH:mm:ss",
            axisYType: "secondary",
            type: "candlestick",
            risingColor: "green",
            fallingColor: "red",
            dataPoints : dataPoints1
          }]
        },

        {
          height: 100,
          toolTip: {
            shared: true
          },
          axisX: {
            crosshair: {
              enabled: true,
              snapToDataPoint: true
            }
          },
          axisY2: {
            prefix: "BTC",
            title: "BTC Vol"
          },
          legend: {
            horizontalAlign: "right"
          },
          data: [{
            yValueFormatString: "##,###.##",
            xValueFormatString: "MMM DD, YYYY HH:mm:ss",
            axisYType: "secondary",
            name: "BTC",
            dataPoints : dataPoints2
          }]
        },

        {
          height: 200,
          toolTip: { shared: true },
          axisX: { crosshair: { enabled: true, snapToDataPoint: true } },
          axisY: { prefix: "USD", title: "USD Vol" },
          legend: { horizontalAlign: "right" },
          data: [{
            yValueFormatString: "$###,###",
            xValueFormatString: "MMM DD, YYYY HH:mm:ss",
            axisYType: "secondary",
            name: "USDT Inflow",
            dataPoints : dataPoints4
          },
          {
            yValueFormatString: "$###,###",
            xValueFormatString: "MMM DD, YYYY HH:mm:ss",
            axisYType: "secondary",
            name: "USDT Outflow",
            dataPoints : dataPoints5
          },{
            yValueFormatString: "$###,###",
            xValueFormatString: "MMM DD, YYYY HH:mm:ss",
            axisYType: "secondary",
            name: "USDT Exchange Vol",
            dataPoints : dataPoints6
          }]
        },

        {
          height: 200,
          toolTip: { shared: true },
          axisX: { crosshair: { enabled: true, snapToDataPoint: true } },
          axisY: { prefix: "USD", title: "USD Vol" },
          legend: { horizontalAlign: "right" },
          data: [
          {
            yValueFormatString: "$###,###",
            xValueFormatString: "MMM DD, YYYY HH:mm:ss",
            axisYType: "secondary",
            name: "USDT Flow Total",
            dataPoints : dataPoints7
          }]
        }


        ],

        navigator: {
          data: [{
            color: "grey",
            dataPoints: dataPoints3
          }]
        },
        rangeSelector: {
          enabled: false
        }
      });

      return {"chart": stockChart, "data": [dataPoints1, dataPoints2, dataPoints3, dataPoints4,
                                            dataPoints5, dataPoints6, dataPoints7] };
    }

    async function populate_binance_data( chart_obj )
    {
        // https://fapi.binance.com/fapi/v1/continuousKlines?pair=btcusdt&interval=5m&contractType=PERPETUAL
        let api_url = "https://fapi.binance.com/fapi/v1/continuousKlines";
        let config = await fetch_url( '?cmd=get_config' );
        
        // the API gets only ~8h of data per call, so we loop over
        let end_timestamp = Math.floor(Date.now());
        let start_timestamp = end_timestamp - config.DEFAULT_CHART_LENGTH; //24h
        while( start_timestamp < end_timestamp )
        {
          let chunk_end_timestamp = start_timestamp + config.BINANCE_FETCH_SIZE;
          // console.log( start_timestamp + config.BINANCE_FETCH_SIZE, end_timestamp );
          let params = {"pair":"btcusdt", "interval":"1m", "contractType":"PERPETUAL", 
                      "startTime": start_timestamp, "endTime": chunk_end_timestamp };
          let prices = await fetch_url( api_url, params );
          for (let entry of prices )
          {
            let d = new Date( entry[0] );
            chart_obj.data[0].push({x: d, //open time
                              y: [Number(entry[1]),  //open
                                  Number(entry[2]),  //high
                                  Number(entry[3]),  //low
                                  Number(entry[4])   //close
                                ],
                              color: entry[1] < entry[4] ? "green" : "red"
                            });
            chart_obj.data[1].push({x: d, y: Number(entry[5]), color: entry[1] < entry[4] ? "green" : "red"});
            chart_obj.data[2].push({x: d, y: Number(entry[4] )}); // close
          }
          start_timestamp += config.BINANCE_FETCH_SIZE;

          chart_obj.chart.render();
        }
    }

    async function fetch_bucket_data( chart_obj )
    {
      let config = await fetch_url( '?cmd=get_config' );
      let url = '?cmd=get_db_buckets';
      // start_timestamp, end_timestamp
      let end_timestamp = Math.floor(Date.now()/1000);
      let start_timestamp = end_timestamp - config.DEFAULT_CHART_LENGTH; //24h

      // console.log( "dashboard state:", dashboard_data.sum);
      if( dashboard_data.sum ) url += "&cursor=" + dashboard_data.sum.api_cursor;
      url += "&start_timestamp=" + start_timestamp + "&end_timestamp=" + end_timestamp;
      let data = await fetch_url(url );
      concord_front( data );
      populate_bucket_data( data, chart_obj );
      populate_bucket_data2( data, chart_obj );
    }

    function populate_bucket_data( data, chart_obj )
    {
      // console.log(data);
      for(let entry of data.buckets_timeseries_exchanges )
      {
        // console.log( entry );
        let d = new Date( entry.timestamp );
        chart_obj.data[3].push({x: d, y: entry.inflow, color: "green"});
        chart_obj.data[4].push({x: d, y: entry.outflow, color: "red"});
        // chart_obj.data[5].push({x: d, y: entry.vol, color: "blue"});
        
      }
    }

    // TODO - refactor!
    function populate_bucket_data2( data, chart_obj )
    {
      // console.log(data);
      for(let entry of data.buckets_timeseries_total )
      {
        // console.log( entry );
        let d = new Date( entry.timestamp );
        chart_obj.data[6].push({x: d, y: entry.vol, color: "blue"});
        // chart_obj.data[6].push({x: d, y: entry.net, color: entry.neet > 0 ? "green" : "red"});
        
      }
    }

    async function fetch_url( url, query = null )
    {
      if( query )
      {
        if( url.slice(-1) != "?" )
          url += "?";
        for( let key in query )
        {
          url += key + "=" + query[key] + "&";
        }
      }

      console.log("fetching", url);
      return await fetch( url )
        .then(response => response.json())
        .then(data => {
          return data;
        }); 
    }


    function concord_front( data )
    {
        dashboard_data.ticks.push( data );
        let d = dashboard_data.sum;
        if( ! d )
        {
          d = data;
          d.api_count_total = data.api_count;
        }
        else
        {
          console.log( "concording data" );
          // use the latest data segment to update our summary DS
          d.inflow += data.inflow;
          d.outflow += data.outflow;
          d.intraflow += data.intraflow;

          d.api_cursor = data.api_cursor;
          d.api_count = data.api_count;
          d.api_count_total += data.api_count;
          
          // charts data was created in the same loop as buckets, so we should be able to concord both in the same loop
          data.sorted_totals.forEach( (item, index) => {
            let key_index = key_in_obj(item.bucket, d.sorted_totals, "bucket" );
            if( key_index < 0 )
            {
              d.sorted_totals.push( item );
              d.chart_data.push( data.chart_data[index] );
            }
            else
            {
              item.totals.forEach((target_item, target_index) => {
                let target_key_index = key_in_obj(target_item.target, d.sorted_totals[ key_index ], "target" );
                if( target_key_index < 0 )
                {
                  d.sorted_totals[ key_index ].push( target_item );
                  d.chart_data[ key_index ].x.push( data.chart_data[index].x[target_index] );
                  d.chart_data[ key_index ].y.push( data.chart_data[index].y[target_index] );
                }
                else
                {
                  d.sorted_totals[ key_index ][ "amount" ] += target_item.amount;
                  d.chart_data[ key_index ].y[target_index] += data.chart_data[index].y[target_index]; 
                }
              });
            }

          });

        }

        console.log( d );
        dashboard_data.sum = d;

        // keeping the template and the rendered html seperate lets us be able to rerender the element later on      
        render( dashboard_data.sum, '#tp-bucket-list', '#buckets-table' );
        render( dashboard_data.sum, '#tp-flow-stats', '#flow-stats' );

        Plotly.newPlot('buckets-chart', dashboard_data.sum.chart_data, {barmode: 'group'} );

    }

    function key_in_obj( key, sorted_totals, obj_attribute_name )
    {
      sorted_totals.forEach( (item, index) => {
        if( item[obj_attribute_name] == key )
          return index; //what if this is the 0th entry???
      });
      return -1;
    }

    function render( data, template_id, target_id )
    {
      Handlebars.registerHelper('format_number', function(value) {
          // return value.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
          return (value).toLocaleString('en-EN', {maximumSignificantDigits:3, maximumFractionDigits: 0} );
      });

      if( ! target_id ) target_id = template_id;
      var template = $(template_id).html();
      var renderer = Handlebars.compile(template);
      let rendered = renderer( data );
      $(target_id).html( rendered );

    }




  </script>

</head>
<body>

<h1>Whale Trade</h1>

<div id="chartContainer" style="height: 900px; width: 100%;"></div>

<br/>

<!-- Total flows in the last 24 hours:
<div id="flow-stats-exchange" ></div> -->
Exchange flows in the last 24 hours:
<div id="flow-stats" ></div>
<div id="buckets-chart"></div>

<br/>

<div id="buckets-table"></div>




<!-- Templates for client-side rendering-->
<template id="tp-flow-stats" >
  Total Inflow: {{format_number inflow }} | 
  Outflow: {{format_number outflow }} | 
  Intraflow: {{format_number intraflow }}
</template>

<template id="tp-bucket-list">
  {{#each sorted_totals}}
    <div class="exchange">
      <h4>{{ this.bucket }}</h4>
      {{#each this.totals }}
        <div>{{ this.target }} : {{ this.amount }}</div>
      {{/each}}
    </div>
  {{/each}}
</template>



</body>
</html>