<!doctype html>
<html lang=pl>
<head>
  <meta charset=utf-8>
  <title>Whale Trade Bot</title>

  <script
        src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
        crossorigin="anonymous"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
  <script src="https://canvasjs.com/assets/script/canvasjs.stock.min.js"></script>

<!--   <script>
    var context = {title: "My New Post", body: "This is my first post!"}
    var result = Handlebars.templates.person(context);

    $(function() {
      $("#entry-template").html(result);
    });
  </script> -->

  <script type="text/javascript">
    dashboard_data = { sum:null, ticks:[] };

    // our entry point
    $( document ).ready( () => {
        console.log( "document loaded" );


        let chart = initialize_chart();
        populate_binance_data(chart)
        .then( () => {
          fetch_bucket_data(chart)
          .then( () => {
            chart.chart.render();

              var ema = calculateEMA(chart.data[3] , 7);
              chart.chart.charts[2].addTo("data", {type: "line", name: "Inflows EMA", showInLegend: true,
                                                    yValueFormatString: "$#,###", dataPoints: ema, color:"green"});
              var ema = calculateEMA(chart.data[4] , 7);
              chart.chart.charts[2].addTo("data", {type: "line", name: "Outflows EMA", showInLegend: true,
                                                    yValueFormatString: "$#,###", dataPoints: ema, color:"red"});


          });
        });

        // let limit = 3;
        // let count = 0;
        // while( count < limit && ( !dashboard_data.sum || dashboard_data.sum.api_count == 100)  )
        // {
        //   count++;
        // }




    });

  function calculateEMA(dps,count) {
    var k = 2/(count + 1);
    var emaDps = [{x: dps[0].x, y: dps[0].y.length ? dps[0].y[3] : dps[0].y}];
    for (var i = 1; i < dps.length; i++) {
      emaDps.push({x: dps[i].x, y: (dps[i].y.length ? dps[i].y[3] : dps[i].y) * k + emaDps[i - 1].y * (1 - k)});
    }
    return emaDps;
  }

    function initialize_chart()
    {
      // https://canvasjs.com/javascript-stockcharts/
      var dataPoints1 = [], dataPoints2 = [], dataPoints3 = [], dataPoints4 = [], dataPoints5 = [];
      var stockChart = new CanvasJS.StockChart("chartContainer",{
        exportEnabled: true,
        theme: "light2",
        title:{ text:"" },
        charts: [{ 
          toolTip: { shared: true },
          axisX: {
            lineThickness: 5,
            tickLength: 0,
            labelFormatter: function(e) { return ""; },
            crosshair: {
              enabled: true,
              snapToDataPoint: true,
              labelFormatter: function(e) { return "" }
            }
          },
          axisY2: { title: "BTC Price", prefix: "â‚¬" },
          legend: { verticalAlign: "top", horizontalAlign: "left" },
          data: [{
            name: "Price (in USDT)",
            yValueFormatString: "##,###.##",
            axisYType: "secondary",
            type: "candlestick",
            risingColor: "green",
            fallingColor: "red",
            dataPoints : dataPoints1
          }]
        },{
          height: 100,
          toolTip: {
            shared: true
          },
          axisX: {
            crosshair: {
              enabled: true,
              snapToDataPoint: true
            }
          },
          axisY2: {
            prefix: "BTC",
            title: "BTC Vol"
          },
          legend: {
            horizontalAlign: "left"
          },
          data: [{
            yValueFormatString: "##,###.##",
            axisYType: "secondary",
            name: "BTC/USDT",
            dataPoints : dataPoints2
          }]
        },{
          height: 200,
          toolTip: { shared: true },
          axisX: {
            crosshair: {
              enabled: true,
              snapToDataPoint: true
            }
          },
          axisY: {
            prefix: "USD",
            title: "USD Vol"
          },
          legend: {
            horizontalAlign: "left"
          },
          data: [{
            yValueFormatString: "###,###",
            axisYType: "secondary",
            name: "USDT Inflow",
            dataPoints : dataPoints4
          },
          {
            yValueFormatString: "###,###",
            axisYType: "secondary",
            name: "USDT Outflow",
            dataPoints : dataPoints5
          }]
        }],

        navigator: {
          data: [{
            color: "grey",
            dataPoints: dataPoints3
          }]
        },
        rangeSelector: {
          enabled: false
        }
      });

      return {"chart": stockChart, "data": [dataPoints1, dataPoints2, dataPoints3, dataPoints4, dataPoints5] };
    }

    async function populate_binance_data( chart_obj )
    {
        // $.getJSON("https://canvasjs.com/data/docs/ltceur2018.json", (data) => {
        //   console.log(data);
        //   for(var i = 1; i < 10; i++){
        //     // console.log( new Date("2018-01-0"+i+"T10:30:0"+i+"Z") );
        //     let d = new Date("2018-01-0"+i+"T10:30:0"+i+"Z");
        //     console.log(d)
        //     dataPoints1.push({x: d, y: [Number(data[i].open), Number(data[i].high), Number(data[i].low), Number(data[i].close)], color: data[i].open < data[i].close ? "green" : "red"});;
        //     dataPoints2.push({x: d, y: Number(data[i].volume_eur), color: data[i].open < data[i].close ? "green" : "red"});
        //     dataPoints3.push({x: d, y: Number(data[i].close)});
        //   }
        //   stockChart.render();
        // });

        // https://fapi.binance.com/fapi/v1/continuousKlines?pair=btcusdt&interval=5m&contractType=PERPETUAL
        let api_url = "https://fapi.binance.com/fapi/v1/" + "continuousKlines?pair=btcusdt&interval=1m&contractType=PERPETUAL";
        console.log( api_url );
        await $.getJSON( api_url, (data) => {
          // console.log( "data:", data);
          for (let entry of data )
          {
            // console.log(entry);
            // let entry_date = new Date( entry[0] );
            // let i = entry_date.getMinutes();
            // let d = new Date("2018-01-01T10:"+i+":00Z");
            let d = new Date( entry[0] );
            // console.log( "d:", d );

            chart_obj.data[0].push({x: d, //open time
                              y: [Number(entry[1]),  //open
                                  Number(entry[2]),  //high
                                  Number(entry[3]),  //low
                                  Number(entry[4])   //close
                                ],
                              color: entry[1] < entry[4] ? "green" : "red"
                            });
            chart_obj.data[1].push({x: d, y: Number(entry[5]), color: entry[1] < entry[4] ? "green" : "red"});
            chart_obj.data[2].push({x: d, y: Number(entry[4] )}); // close
          }
        });
    }

    async function fetch_bucket_data( chart_obj )
    {
      let url = '?cmd=get_db_buckets';
      // start_timestamp, end_timestamp
      let end_timestamp = Math.floor(Date.now()/1000);
      let start_timestamp = end_timestamp - (3600 * 8 ) ; // last 8 hours to make it same scale as pricing

      // console.log( "dashboard state:", dashboard_data.sum);
      if( dashboard_data.sum ) url += "&cursor=" + dashboard_data.sum.api_cursor;
      url += "&start_timestamp=" + start_timestamp + "&end_timestamp=" + end_timestamp;
      await fetch( url )
        .then(response => response.json())
        .then(data => {
          // console.log(data)
          concord_front( data );
          populate_bucket_data( data, chart_obj );
          // if( dashboard_data.sum.api_count == 100 )
          //   setTimeout( fetch_data, 4000); // we wait a few seconds between calls - rate limit of 10 per min!
        });
    }

    function populate_bucket_data( data, chart_obj )
    {
      // console.log(data);
      for(let entry of data.buckets_timeseries )
      {
        console.log( entry );
        let d = new Date( entry.timestamp );
        chart_obj.data[3].push({x: d, y: entry.inflow, color: "green"});
        chart_obj.data[4].push({x: d, y: entry.outflow, color: "red"});
        
      }
    }


    function concord_front( data )
    {
      dashboard_data.ticks.push( data );
      let d = dashboard_data.sum;
      if( ! d )
      {
        d = data;
        d.api_count_total = data.api_count;
      }
      else
      {
        console.log( "concording data" );
        // use the latest data segment to update our summary DS
        d.inflow += data.inflow;
        d.outflow += data.outflow;
        d.intraflow += data.intraflow;

        d.api_cursor = data.api_cursor;
        d.api_count = data.api_count;
        d.api_count_total += data.api_count;
        
        // charts data was created in the same loop as buckets, so we should be able to concord both in the same loop
        data.sorted_totals.forEach( (item, index) => {
          let key_index = key_in_obj(item.bucket, d.sorted_totals, "bucket" );
          if( key_index < 0 )
          {
            d.sorted_totals.push( item );
            d.chart_data.push( data.chart_data[index] );
          }
          else
          {
            item.totals.forEach((target_item, target_index) => {
              let target_key_index = key_in_obj(target_item.target, d.sorted_totals[ key_index ], "target" );
              if( target_key_index < 0 )
              {
                d.sorted_totals[ key_index ].push( target_item );
                d.chart_data[ key_index ].x.push( data.chart_data[index].x[target_index] );
                d.chart_data[ key_index ].y.push( data.chart_data[index].y[target_index] );
              }
              else
              {
                d.sorted_totals[ key_index ][ "amount" ] += target_item.amount;
                d.chart_data[ key_index ].y[target_index] += data.chart_data[index].y[target_index]; 
              }
            });
          }

        });

      }

      console.log( d );
      dashboard_data.sum = d;

      // keeping the template and the rendered html seperate lets us be able to rerender the element later on      
      render( dashboard_data.sum, '#tp-bucket-list', '#buckets-table' );
      render( dashboard_data.sum, '#tp-flow-stats', '#flow-stats' );

      Plotly.newPlot('buckets-chart', dashboard_data.sum.chart_data, {barmode: 'group'} );

    }

    function key_in_obj( key, sorted_totals, obj_attribute_name )
    {
      sorted_totals.forEach( (item, index) => {
        if( item[obj_attribute_name] == key )
          return index; //what if this is the 0th entry???
      });
      return -1;
    }

    function render( data, template_id, target_id )
    {
      Handlebars.registerHelper('format_number', function(value) {
          // return value.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
          return (value).toLocaleString('en-EN', {maximumSignificantDigits:3, maximumFractionDigits: 0} );
      });

      if( ! target_id ) target_id = template_id;
      var template = $(template_id).html();
      var renderer = Handlebars.compile(template);
      let rendered = renderer( data );
      $(target_id).html( rendered );

    }




  </script>

</head>
<body>

<h1>Whale Trade</h1>

<div id="chartContainer" style="height: 500px; width: 100%;"></div>

<br/>

Total flows in the last 8 hours:
<div id="flow-stats" ></div>
<div id="buckets-chart"></div>

<br/>

<div id="buckets-table"></div>




<!-- Templates for client-side rendering-->
<template id="tp-flow-stats" >
  Total Inflow: {{format_number inflow }} | 
  Outflow: {{format_number outflow }} | 
  Intraflow: {{format_number intraflow }}
</template>

<template id="tp-bucket-list">
  {{#each sorted_totals}}
    <div class="exchange">
      <h4>{{ this.bucket }}</h4>
      {{#each this.totals }}
        <div>{{ this.target }} : {{ this.amount }}</div>
      {{/each}}
    </div>
  {{/each}}
</template>



</body>
</html>